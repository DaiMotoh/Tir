<h1>What Is Tir?</h1>

Tir is an experimental web framework for the <a
href="http://mongrel2.org/">Mongrel2 webserver</a> and <a
href="http://www.lua.org/">Lua programming language</a>.  The purpose of Tir is
to play with the idea of a <b>State Agnostic</b> web framework.  Tir lets you
create handlers that work in various configurations as needed by your
application requirements.  You create your application using a <a
href="#natural">natural coroutine style</a> of handler, then make another part
<a href="#stateless">stateless</a>, and still have other parts using an
<a href="#evented">evented/callback style</a>.


<h2>Getting Started</h2>

Tir is very alpha, but it is being used on a few projects.  Feel free to grab
the code and if you want to help, then contact zedshaw@zedshaw.com for more
information.

You can read the [Install], [GettingStarted] and the [ContributorInstructions] for information
on how to get up and running with Tir.

The source to Tir is available at <a
href="http://tir.mongrel2.org/downloads/tir-0.9-1.tar.gz">http://tir.mongrel2.org/downloads/tir-0.9-1.tar.gz</a>.


<h1>Tir's Philosophy</h1>


<h2>Simple Templating Language</h2>

Tir uses embedded Lua as it's templating language, which means you get a real
language and not some crippled one someone smarter than you think you
<b>should</b> be using.  And Lua already looks like most of the nice template
languages out there:

<verbatim>
{% if #results > 0 then %}
<ul>
    {% for _,result in ipairs(results) do %}
    <li>{{ result }}</li>
    {% end %}
</ul>
{% else %}
<p>We'll add "{{ q }}" as a new one.</p>
{% end %}
</verbatim>

<h2>Multiple Little Processes</h2>

Tir also uses <a href="http://zeromq.org">ZeroMQ</a> and <a
href="http://mongrel2.org">Mongrel2</a> to run the application as a set of
small processes for each major routing, rather than one monolithic process.  In
the above two examples, each <b>Tir.start</b> line is a single process.

You can also build on this to flex and warp the size of your processes as you
need, and locate them or cluster them however you like.  By default it shoots
for small little processes, but nothing prevents you from doing others.

<h2>Builtin Background Tasks</h2>

Tir.Task lets you create and connect to ready to run 0MQ background task
processes so you can offload long running tasks and avoid holding up web
requests.  They're designed to be very easy to use, but still flexible enough
to let you do what you need.  By default they use PUB/SUB sockets, but you
can change that with a setting.  You can also put the background tasks on
clusters of machines and nearly anything else you need to do.  Messages are
simply just JSON encoded Lua structures.

Here's a Task that just dumps it's args.

<verbatim>
require 'tir/engine'

function test(args)
    Tir.dump(args)
end

Tir.Task.start { main = test, spec = 'ipc://run/photos' }
</verbatim>

And here's a sample Handler that can talk to it:

<verbatim>
require 'tir/engine'

local conn = Tir.Task.connect { spec = 'ipc://run/photos' }

function main(web, req)
    conn:send('photo', req.headers)
    web:ok()
end

Tir.stateless {route='/Task', main=main}
</verbatim>

<h2>Unit Test Support</h2>

New in 0.9, Tir now has decent unit testing in the <b>tir/testing</b> library
and there's a sample test in the [GettingStarted] guide that shows how it's
done.

<h2>Async Ready</h2>

Because Tir uses Mongrel2 it already support async operation, streaming,
regular HTTP, HTTP long poll, and flash/jssockets.


<h2>No ORM</h2>

Tir comes without an ORM by default.  People would probably hate any ORM I
wrote and there's plenty of options you can add.


<h2>No Core</h2>

This isn't really a Tir feature, but do you hate when there's bugs in your core
libraries and that guy who "owns" the broken library refuses to fix it?  Me
too, that's why <a href="http://lua.org">Lua</a> and <a
href="http://luarocks.org/">LuaRocks</a> are awesome.  You get a tight core
language that's completely described <a
href="http://www.lua.org/manual/5.1/">in a few HTML pages</a> and then install
all the platform libraries you need with LuaRocks.

No more gatekeepers with Lua.

